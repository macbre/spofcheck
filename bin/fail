#!/usr/bin/env node

/**
* fail
* 
* CLI for frontend spof detection
*
**/

// dependencies
var spof = require('../lib/spof.js').spof,
	path = require('path'),
	fs = require('fs'),
	nopt = require('nopt'),
	request = require('request'),
	async = require('async'),
	jsdom = require('jsdom').jsdom,
	$ = require('jquery');

// Setting jsdom global config
require("jsdom").defaultDocumentFeatures = {
	FetchExternalResources: false,
	ProcessExternalResources: false,
	MutationEvents: false,
	QuerySelector: false
};

// Locals
var options = {
		"outputdir": path,
		"format": String,
		"help": String
	},
	shortHand = {
		"o": ['--outputdir'],
		"f": ['--format'],
		"h": ['--help']
	};

// options
options = nopt(options, shortHand);

/**
 * Retrieve the list of external CSS URLs in the page 
 * @param {Object} $dom The DOM handler (jQuery) for the page.
 * @return {Array} An array of URLs. 
 * @method getCssUrls
 */
function getCssUrls($dom) {
	// Retrieving the link elements, using both type and rel attributes 
	var urls = [].concat($dom('link[type="text/css"]').get())
				 .concat($dom('link[rel="stylesheet"]').get());
	
	// Retrieving the actual urls
	urls = urls.map(function(url){
		return url.href;
	})
	
	// removing duplicates and returning
	return urls.filter(function(url, index) {
		return this.indexOf(url) == index;
	}, urls);
}

/**
 * Creates a CSS callback function stack to be executed after each external
 * CSS is loaded 
 * @param {Array} urls The external CSS URLs
 * @return {Array} An array of functions. 
 * @method getCssFnStack
 */
function getCssFnStack(urls) {
	var cssFnStack = [];
	urls.forEach(function(url) {
		cssFnStack.push(function(callback) {
			request(url, function(error, response, body) {
				if(error || response.statusCode != 200) {
					body = '';
				}
				callback(null, body);
			})
		});
	});
	return cssFnStack;
}

function write(message) {
	// TODO
	var file = options.outputdir ? options.outputdir + '/junit.xml' : 1,
		fd = fs.openSync(file, 'w');;
	//console.log(file);
	fs.writeSync(1, message);
}

/**
 * Creates a CSS callback function stack to be executed after each external
 * CSS is loaded 
 * @param {Array} args The arguments provided in command line 
 * @method exec
 */
function exec(args) {
	var usage = '\n' +
				'USAGE: fail http://www.xyz.com',
		formatter = spof.getFormatter(options.format || 'junit-xml'),
		length = args.length,
		counter = 0,
		formattedResultsQ = [], // Queue to hold the formatted results
		/**
		 * Flush the spof results to a file 
		 * @param {String} results The spof results to flush 
		 * @method flush
		 * @private
		 */
		flush = function(results) {
			var buffer = [],
				output; 
			console.log('Flushing the results ...\n');
			// Buffer the formatter start
			output = formatter.startFormat();
			output && buffer.push(output);
			
			// Buffer the results
			results.length && buffer.push(results);
			
			// Buffer the formatter end
			output = formatter.endFormat();
			output && buffer.push(output);
			
			// Flush the buffer
			write(buffer.join('\n'));
			console.log('\n\nSPOF check DONE!\n');
		};
	
	if(!length || options.help) {
		console.log(usage);
		process.exit(0);
	}
	
	if(!formatter) {
		console.log('spof:  Unknown format \'' + options.format + '\'. Cannot proceed');
		process.exit(0);		
	}
		
	args.forEach(function(url){
		// Check if http is present, else append it
		url = /^http:\/\//.test(url) ? url: 'http://' + url;	
		console.log('Analyzing ' + url + ' ...');
		request(url, function(error, response, body) {
			if(!error && response.statusCode == 200) {				
					// Create the DOM window from the page 
				var win = jsdom(body, null, null).createWindow(),
					// Get the jQuery DOM interface
					$dom = $.create(win),
					// Create the CSS function stack for the async parallelization
					cssFnStack = getCssFnStack(getCssUrls($dom));
				
				// Retrieve the CSS results in parallel and join them
				console.log('Processing external CSS resources for ' + url + ' ...');
				async.parallel(cssFnStack, function(err, results) {
					var result = spof.analyze($dom, results.join()),
						formattedResults = formatter.formatResults(result, url);

					// Write the formatted results
					if(formattedResults && formattedResults.length) {
						formattedResultsQ.push(formattedResults);
					}
					
					// Flush the results if last url
					if(++counter === length) {
						flush(formattedResultsQ.join('\n'));
					}
				});				
			} else {
				// TODO
			}
		});
	});
}

// Start the execution
exec(options.argv.remain);
